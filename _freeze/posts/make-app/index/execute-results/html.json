{
  "hash": "5be66784dabc1e608fe27404e0557c17",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"第一次用python做exe，不會的問AI\"\nauthor: \"紙魚\"\ndate: \"2025-08-9\"\ncategories: [note,python,toys,]\nformat:\n  html:\n    code-fold: true\n# jupyter: python3\n---\n\n這篇文章有點流水帳，就是一篇製作玩具的過程隨筆。用AI寫程式可以做到自己以前做不到的，但遇到問題還是要想辦法解決，解決問題還是需要思考跟經驗，所以我想還是紀錄一下，供日後參考囉。\n\n---\n\n# 緣起\n\n因為最近覺得用眼過度，想要一個小玩具來提醒自己要定時休息，由於倒數計時的功能不會很複雜，自己用還可以客製化自己想要的功能，所以就來動手做做看！\n\n我先叫AI生了靜態倒數計時器的網頁，UI看起來很不錯：\n\n[Alt text](image1.png)\n\n不過很就發現，它沒有辦法準時計時，因為瀏覽器會暫停閒置的網站，哭哭。\n\n然後我就把歪腦筋動到了用 python 製作 exe 上，之前只是耳聞過 python 可以做到，但我其實沒有嘗試過製作一個 exe 檔，正好是個機會 :) 就來試試看吧！\n\n::: {#29534e20 .cell execution_count=1}\n``` {.python .cell-code}\nfor i in range(3):\n    print(i)\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import rcParams\n\n# 設定中文字型（這裡以 Windows 常見的微軟正黑體為例）\nrcParams['font.family'] = 'Microsoft JhengHei'\n\n# 防止負號顯示為方塊\nplt.rcParams['axes.unicode_minus'] = False\n\n# 資料\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\n# 繪圖\nplt.plot(x, y, marker='o', linestyle='-', color='blue')\n\n# 標題與標籤\nplt.title('簡單的折線圖')\nplt.xlabel('X 軸')\nplt.ylabel('Y 軸')\n\n# 顯示圖形\nplt.grid(True)\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-2.png){}\n:::\n:::\n\n\n## 使用環境\n\n- Windows 11\n- python version: 3.12.5\n\n套件:\n- tkinter\n> 做 gui 的基本套件，優點是簡單，缺點是有些陽春\n- \n- pyinstaller\n\n# 製作過程\n\n\n\n## 第一步：開需求\n\n我的需求如下：\n\n- 每30分鐘跳視窗提醒休息5分鐘，使用者按按鈕再繼續計時。\n- 螢幕上要顯示剩下幾分鐘。\n- 以秒為單位更新畫面。\n\n\n## 第二步：丟AI生架構\n\n把需求丟給AI後，生了一個架構出來\n\n```python\nimport tkinter as tk\nfrom tkinter import messagebox\nimport time\nimport threading\n\n# 時間設定（秒）\nWORK_DURATION = 30 * 60   # 30分鐘\nBREAK_DURATION = 5 * 60   # 5分鐘\n\n# GUI 主視窗\nroot = tk.Tk()\nroot.title(\"番茄鐘計時器\")\nroot.geometry(\"320x180\")\nroot.resizable(False, False)\n\nstatus_label = tk.Label(root, text=\"準備中...\", font=(\"Arial\", 16))\nstatus_label.pack(pady=10)\n\ntime_label = tk.Label(root, text=\"剩餘時間：00:00\", font=(\"Arial\", 32))\ntime_label.pack(pady=10)\n\n# 控制計時的旗標\nstop_flag = threading.Event()\n\ndef format_time(seconds):\n    minutes = seconds // 60\n    secs = seconds % 60\n    return f\"{minutes:02}:{secs:02}\"\n\ndef run_timer(duration, status_text, done_message):\n    remaining = duration\n\n    # 更新狀態文字\n    root.after(0, lambda: status_label.config(text=status_text))\n\n    while remaining >= 0 and not stop_flag.is_set():\n        display = f\"剩餘時間：{format_time(remaining)}\"\n        root.after(0, lambda d=display: time_label.config(text=d))\n        time.sleep(1)\n        remaining -= 1\n\n    if not stop_flag.is_set():\n        root.after(0, lambda: messagebox.showinfo(\"提醒\", done_message))\n\ndef timer_loop():\n    while not stop_flag.is_set():\n        run_timer(WORK_DURATION, \"⏱ 工作中\", \"⏰ 工作時間結束！請休息 5 分鐘\")\n        run_timer(BREAK_DURATION, \"☕ 休息中\", \"✅ 休息結束，準備進入下一輪\")\n\ndef start_timer():\n    stop_flag.clear()\n    threading.Thread(target=timer_loop, daemon=True).start()\n\ndef stop_timer():\n    stop_flag.set()\n    status_label.config(text=\"計時已停止\")\n    time_label.config(text=\"剩餘時間：00:00\")\n\n# 按鈕 UI\nbtn_frame = tk.Frame(root)\nbtn_frame.pack(pady=5)\n\nstart_btn = tk.Button(btn_frame, text=\"開始計時\", command=start_timer, font=(\"Arial\", 12))\nstart_btn.pack(side=tk.LEFT, padx=10)\n\nstop_btn = tk.Button(btn_frame, text=\"結束計時\", command=stop_timer, font=(\"Arial\", 12))\nstop_btn.pack(side=tk.RIGHT, padx=10)\n\n# 啟動 GUI 主迴圈\nroot.mainloop()\n```\n\n但用 `tkinter` 做出來的介面有點醜，於是改用`customtkinte`替代，再追加希望有聲音提醒的需求，於是有了第二版：\n\n```python\nimport customtkinter as ctk\nimport time\nimport threading\nfrom tkinter import messagebox\nfrom playsound import playsound\n\nWORK_DURATION = 30 * 60\nBREAK_DURATION = 5 * 60\nSOUND_FILE = \"ding.mp3\"\n\nctk.set_appearance_mode(\"dark\")  # 或 \"light\"\nctk.set_default_color_theme(\"blue\")\n\napp = ctk.CTk()\napp.title(\"番茄鐘計時器\")\napp.geometry(\"360x220\")\n\nstatus_label = ctk.CTkLabel(app, text=\"準備中...\", font=(\"Arial\", 18))\nstatus_label.pack(pady=10)\n\ntime_label = ctk.CTkLabel(app, text=\"剩餘時間：00:00\", font=(\"Arial\", 32))\ntime_label.pack(pady=10)\n\nstop_flag = threading.Event()\n\ndef format_time(seconds):\n    minutes = seconds // 60\n    secs = seconds % 60\n    return f\"{minutes:02}:{secs:02}\"\n\ndef run_timer(duration, status_text, done_message):\n    remaining = duration\n    status_label.configure(text=status_text)\n    while remaining >= 0 and not stop_flag.is_set():\n        time_label.configure(text=f\"剩餘時間：{format_time(remaining)}\")\n        time.sleep(1)\n        remaining -= 1\n    if not stop_flag.is_set():\n        threading.Thread(target=lambda: playsound(SOUND_FILE), daemon=True).start()\n        messagebox.showinfo(\"提醒\", done_message)\n\ndef timer_loop():\n    while not stop_flag.is_set():\n        run_timer(WORK_DURATION, \"⏱ 工作中\", \"⏰ 工作時間結束！請休息 5 分鐘\")\n        run_timer(BREAK_DURATION, \"☕ 休息中\", \"✅ 休息結束，準備進入下一輪\")\n\ndef start_timer():\n    stop_flag.clear()\n    threading.Thread(target=timer_loop, daemon=True).start()\n\ndef stop_timer():\n    stop_flag.set()\n    status_label.configure(text=\"計時已停止\")\n    time_label.configure(text=\"剩餘時間：00:00\")\n\nbtn_frame = ctk.CTkFrame(app)\nbtn_frame.pack(pady=10)\n\nstart_btn = ctk.CTkButton(btn_frame, text=\"開始計時\", command=start_timer)\nstart_btn.pack(side=\"left\", padx=10)\n\nstop_btn = ctk.CTkButton(btn_frame, text=\"結束計時\", command=stop_timer)\nstop_btn.pack(side=\"right\", padx=10)\n\napp.mainloop()\n```\n\n好看多了！\n\n其實不用聲音檔，光有這樣的架構，再寫個 bat 呼叫腳本其實就能用了，但到這裡我開始越來越貪心，想要弄得更精細，於是又加了2個需求\n\n1. 聲音檔分成2個，工作時和休息時的音效不同\n2. 聲音只播一次，且要跟訊息一起出現\n\n## 第三步：微調程式與參數\n\n### 聲音檔分成2個\n\n實際上需要改動2個地方，一個是區分工作跟休息，另一個是\n\n\n```python\n# 主循環：工作 → 休息 → 循環\ndef timer_loop():\n    while not stop_flag.is_set():\n        run_timer(WORK_DURATION, \"⏱ 工作中\", \"⏰ 工作結束！請休息 5 分鐘\", SOUND_FILE)\n        run_timer(BREAK_DURATION, \"☕ 休息中\", \"✅ 休息結束，準備進入下一輪\", SOUND_FILE2)\n```\n\n## 聲音只播一次，且跟訊息一起出現\n\n這需要調整兩個函數：\n\n```python\n# 播放音效（非阻塞）\ndef play_sound(file):\n    try:\n        pygame.mixer.music.load(file)\n        pygame.mixer.music.play()\n    except Exception as e:\n        print(f\"⚠ 播放音效失敗：{e}\")\n\n# 執行計時器\n# 這裡使用非阻塞方式播放音效，避免阻塞主線\ndef run_timer(duration, status_text, done_message, sound_file):\n    remaining = duration\n    status_label.configure(text=status_text)\n\n    while remaining >= 0 and not stop_flag.is_set():\n        time_label.configure(text=f\"剩餘時間：{format_time(remaining)}\")\n        time.sleep(1)\n        remaining -= 1\n\n    if not stop_flag.is_set():\n        play_sound(sound_file)  # ✅ 非阻塞播放音效\n        messagebox.showinfo(\"提醒\", done_message)  # ✅ 等待使用者按下「確定」\n```\n\n\n### 配合打包成exe的調整\n\n因為py檔在執行程式時會認附加檔案的路徑，即使打包成exe後也是如此，因此需要就這一段做微調。\n\n```python\nimport os\nimport sys\n\n# 取得正確路徑（支援 pyinstaller 打包後的執行檔）\ndef resource_path(relative_path):\n    \"\"\"取得資源真實路徑（支援開發階段與打包後）\"\"\"\n    try:\n        base_path = sys._MEIPASS  # PyInstaller 的暫存資料夾\n    except Exception:\n        base_path = os.path.abspath(\".\")\n    return os.path.join(base_path, relative_path)\n\n# 使用方式：\nsound_file_path = resource_path(\"sound.wav\")\n# 程式使用 resource_path()，就可以正確找到聲音檔了。\n\n# 例如播放聲音\nimport playsound\nplaysound.playsound(sound_file_path)\n```\n\n執行時，PyInstaller 會自動把聲音檔解壓到臨時目錄中，這樣就可以找到聲音檔了。\n\n\n\n## 第四步：打包成exe\n\n用`pyinstaller`進行打包，首先要先安裝套件:\n\n```bash\npip install pyinstaller\n```\n\n### 基本指令\n\n打包的基本指令為\n```bash\npyinstaller your_script.py\n```\n\n執行完成後系統會提示放在 `.\\dist`的資料夾下，具體結構為：\n\n```\nyour_script/\n├── dist/\n│   └── your_script.exe  ← 可執行檔在這裡\n├── build/\n├── your_script.spec \n```\n`build/` 和 `.spec` 是中間產物，可以保留也可以刪除。\n\n除此之外還有常用附加指令：\n\n| 參數                | 說明                        |\n| ----------------- | ------------------------- |\n| `--onefile`       | 打包成單一 `.exe` 檔案（預設會拆成很多檔） |\n| `--noconsole`     | 不顯示命令列（適合正式 GUI 程式），不輸入時點擊`exe`會跳出cmd畫面。        |\n| `--icon=icon.ico` | 指定執行檔圖示                   |\n\n> 實作注意事項：\n> 1. `--onefile`建議必加，不然會跑出很多資料夾or檔案 ~~有點像遊戲拆包~~\n> 2. `--noconsole` 在測試階段可以不用加入，方便檢查程式被打包成`exe`後會不會有前面沒有出現過的錯誤訊息。\n\n\n### 加入附加檔\n\n假設加入的聲音為`sounds.wav`，那麼指令為：\n\n```bash\n--add-data \"sounds.wav;.\"\n```\n這裡的`;`後面是資料夾的意思，`.`表示跟主程式一樣放在同一個資料夾。如果有兩個就在後面繼續使用此指令。\n\n如果聲音檔跟主程式放在不同資料夾，像這樣：\n\n```\nproject/\n├── main.py\n└── sounds/\n    ├── click.wav\n    └── error.wav\n```\n那指令就是：\n\n```bash\npyinstaller --onefile --add-data \"sounds;sounds\" main.py\n```\n\n代表「把 `sounds/` 整個資料夾加到 `.exe` 所在目錄中」\n\n\n### 加入icon但沒顯示\n\n你遇到的這個問題其實**蠻常見的**，屬於 Windows 的圖示快取（icon cache）或顯示方式的問題，而不是 PyInstaller 的 bug。\n\n---\n\n#### 問題簡述\n\n你打包的 `.exe`：\n\n*  在「右鍵 > 內容」視窗中，icon 有成功顯示\n*  但桌面或檔案總管中，`.exe` 的圖示卻不是你設定的 icon（可能是預設的 Python 圖示，或空白圖示）\n\n---\n\n####  原因解析\n\n這通常是由於以下幾個原因之一：\n\n##### 1. **Windows icon 快取沒更新**\n\n* Windows 為了加快載入速度，會快取圖示。\n* 打包後新圖示沒即時更新，看起來像「圖示沒換」。\n\n##### 2. **你 icon 太大或格式不正確**\n\n* `.ico` 文件實際上應該包含多個尺寸（16x16, 32x32, 48x48, 256x256 等）。\n* 若 `.ico` 裡面只放了單一尺寸，可能無法在檔案總管中正常顯示。\n\n##### 3. **桌面或目錄載入的是舊版 `.exe`**\n\n* 有時打包後你雙擊的是舊的 `.exe`（Windows 快取會讓你不知不覺點到舊檔）\n* 特別是打包後放在 `dist/` 裡，但桌面捷徑沒更新\n\n---\n\n#### 解法一覽\n\n##### 解法 1：強制清除 icon 快取\n\n1. 打開「任務管理員」 > 結束 `explorer.exe`\n2. 在命令提示字元輸入以下指令：\n\n```bash\ndel /A /Q \"%localappdata%\\IconCache.db\"\n```\n\n3. 然後重新啟動 `explorer.exe`，或重新啟動電腦\n\n---\n\n##### 解法 2：確保 `.ico` 格式正確\n\n使用支援多尺寸的 `.ico` 文件（建議用這些尺寸）：\n\n* 16x16\n* 32x32\n* 48x48\n* 64x64pi\n* 128x128\n* 256x256\n\n###### 你可以用這些網站製作：\n\n* [https://www.icoconverter.com/](https://www.icoconverter.com/)\n* [https://convertico.com/](https://convertico.com/)\n\n把一張高解析度 PNG 上傳，勾選多個 icon 尺寸，再下載 `.ico`。\n\n---\n\n##### 解法 3：確認打包指令正確\n\n再次確認你用了這樣的指令：\n\n```bash\npyinstaller --onefile --noconsole --icon=your_icon.ico main.py\n```\n\n* `.ico` 檔案路徑不要包含空格或中文\n* 放在與 `main.py` 同一層最穩定\n\n---\n\n##### 解法 4：刪掉舊檔案，重新打包\n\n* 刪掉 `dist/`, `build/`, `__pycache__`，重新打包一次\n* 用全新生成的 `.exe` 測試，不要點以前建立的捷徑或舊檔案\n\n```bash\npyinstaller --clean --onefile --noconsole --icon=your_icon.ico main.py\n```\n\n---\n\n#### 檢查點（總結）\n\n| 檢查項目              | 說明                         |\n| ----------------- | -------------------------- |\n| ✅ `--icon` 有加     | 確保有用 `--icon=xxx.ico`      |\n| ✅ ICO 檔有效         | 使用多尺寸 `.ico`               |\n| ✅ 清除快取            | 手動刪除 icon cache 或重開機       |\n| ✅ 用新打包的 `.exe` 測試 | 確保不是舊檔或捷徑                  |\n| ✅ dist/ 裡的檔案      | 用那個 `.exe` 來測試 icon 是否真的有效 |\n\n---\n\n如果你願意的話，你可以提供你的 `.ico` 檔（或說它的來源），我可以幫你檢查這個檔案是否格式正確。或者，你也可以提供你的完整打包指令，我可以幫你確認是否少了什麼。\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}